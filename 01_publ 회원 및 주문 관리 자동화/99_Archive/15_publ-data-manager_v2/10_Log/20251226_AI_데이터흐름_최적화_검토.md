---
created: 2025-12-26T1720
modified: 2025-12-26T1720
---
## Summary

publ-data-manager v2의 데이터 흐름과 처리 방식을 비판적으로 검토. 중복 API 호출, 메모리 효율성, 에러 처리, 정합성 로직 등에서 개선 필요 사항 발견.

## Why (왜)

#### 배경

현재 시스템이 정상 동작하고 있으나, 다음 상황에서 문제가 발생할 수 있음:
- 데이터 규모 증가 시 성능 저하
- 네트워크 오류 시 부분 실패 처리 미흡
- 유지보수 시 코드 중복으로 인한 복잡성

#### 목적

1. 잠재적 문제점 사전 식별
2. 최적화 가능 영역 파악
3. 향후 개선 로드맵 수립

## What (무엇을)

#### 검토 대상

| 파일 | 역할 | 라인 수 |
|------|------|---------|
| main.py | 워크플로우 조율 | 186 |
| downloader.py | CSV 다운로드 | 249 |
| syncer.py | Supabase 동기화 | 346 |
| airtable_syncer.py | Airtable 동기화 | 306 |
| config.py | 설정 관리 | 104 |

#### 결과물

---

## 검토 결과

### 1. 중복 API 호출 (심각도: 높음)

#### 문제점

```
main.py 실행 흐름:

STEP 2: sync_all()
    └─ Supabase 전체 데이터 조회 (Members, Orders, Refunds)

STEP 3: sync_all_to_airtable(supabase)
    └─ Supabase 전체 데이터 **다시** 조회 (동일 데이터)
```

**코드 위치:**
- `syncer.py:310-341` - sync_all()에서 데이터 처리
- `airtable_syncer.py:251-293` - 동일 데이터 재조회

#### 영향

- API 호출 2배 증가
- 실행 시간 증가
- Supabase 할당량 소모

#### 개선안

```python
# 현재: 데이터를 버림
sync_results = sync_all()

# 개선: 처리된 데이터를 전달
sync_results, processed_data = sync_all()
airtable_results = sync_all_to_airtable(supabase, processed_data)
```

---

### 2. 메모리 효율성 (심각도: 중간)

#### 문제점

모든 기존 키를 메모리에 로드:

```python
# syncer.py:31-49
def get_existing_keys(supabase, table_name, key_column):
    all_keys = set()  # 전체 키를 메모리에 보관
    while True:
        result = supabase.table(table_name).select('*').range(...)
        for row in result.data:
            all_keys.add(row.get(key_column))
    return all_keys
```

```python
# airtable_syncer.py:18-25
def get_existing_records(table, key_field):
    existing = {}
    for record in table.all():  # 전체 레코드 메모리 로드
        existing[key_value] = record['id']
    return existing
```

#### 영향

| 데이터 규모 | 예상 메모리 사용 |
|-------------|------------------|
| 1,000건 | ~1MB |
| 10,000건 | ~10MB |
| 100,000건 | ~100MB+ (문제 발생 가능) |

#### 개선안

**Option A: 스트리밍 처리**
```python
# 배치 단위로 처리하며 메모리 해제
for batch in get_batches(csv_data, 1000):
    existing = get_existing_keys_for_batch(batch_keys)
    process_batch(batch, existing)
```

**Option B: 데이터베이스 레벨 비교**
```python
# Supabase에서 직접 비교 (IN 쿼리)
new_keys = get_keys_not_in_db(csv_keys)
```

---

### 3. 에러 처리 부족 (심각도: 높음)

#### 문제점

**3-1. 배치 삽입 실패 시 전체 실패**

```python
# syncer.py:80-83
for i in range(0, len(new_records), config.BATCH_SIZE):
    batch = new_records[i:i + config.BATCH_SIZE]
    result = supabase.table(...).insert(batch).execute()
    # 실패 시 나머지 배치도 처리 안됨
```

**3-2. 트랜잭션 없음**

```
시나리오:
1. Orders 100개 삽입 성공
2. Refunds 50개 삽입 중 네트워크 오류
3. is_refunded 업데이트 안됨
→ 데이터 불일치 상태
```

**3-3. 재시도 로직 없음**

```python
# 현재: 실패하면 그냥 종료
try:
    result = supabase.table(...).insert(batch).execute()
except Exception as e:
    print(f"오류: {e}")
    # 재시도 없음
```

#### 개선안

```python
# 재시도 + 부분 성공 처리
def insert_with_retry(table, records, max_retries=3):
    failed_records = []
    for batch in batches(records, BATCH_SIZE):
        for attempt in range(max_retries):
            try:
                table.insert(batch).execute()
                break
            except Exception as e:
                if attempt == max_retries - 1:
                    failed_records.extend(batch)
                time.sleep(2 ** attempt)  # 지수 백오프
    return failed_records
```

---

### 4. 정합성 로직 결함 (심각도: 중간)

#### 문제점

**4-1. 환불 상태 변경 미처리**

```python
# syncer.py:173-181 - 상태 변경 감지는 하지만...
if existing_status != new_status:
    update_records.append({...})

# ...Orders.is_refunded 업데이트는 신규 Refunded만 처리
# syncer.py:186-196
if record.get('Refund Status') == 'Refunded':
    new_refunded_orders.append(...)
```

**누락 시나리오:**
```
1. 환불 요청 (Refund Status = "Requested")
2. 나중에 환불 승인 (Refund Status = "Refunded")
3. 상태 변경은 UPDATE되지만...
4. Orders.is_refunded는 업데이트 안됨! ← 버그
```

**4-2. check_integrity() 제한**

```python
# syncer.py:234-292
# 이 함수도 신규 Refunded만 찾음
# "Requested → Refunded" 변경 건은 탐지 못함
```

#### 개선안

```python
# sync_refunds() 수정
if update_records:
    for update in update_records:
        # 상태 업데이트
        supabase.table(refunds_table).update({...})

        # Refunded로 변경된 경우 Orders도 업데이트
        if update['new_status'] == 'Refunded':
            supabase.table(orders_table).update({
                'is_refunded': True
            }).eq('Order Number', update['order_number']).execute()
```

---

### 5. Airtable Linked Records 타이밍 문제 (심각도: 낮음)

#### 문제점

```python
# airtable_syncer.py 실행 순서:
1. Members 동기화 (신규 추가)
2. Orders 동기화 (Member Linked Record 연결 시도)
   └─ 문제: 방금 추가된 Members의 record_id를 모름!
```

```python
# airtable_syncer.py:106
existing_members = get_existing_records(members_table, 'Member Code')
# → 이 시점에 이미 Members 동기화 완료되었으므로 OK

# 하지만 같은 배치 내에서:
# - Member A 생성
# - Order 1 생성 (Member A 연결 시도)
# → Member A의 record_id가 existing_members에 없음
```

#### 영향

- 신규 회원의 첫 주문에 Linked Record 누락
- 다음 실행 시 복구되지 않음 (신규가 아니므로)

#### 개선안

```python
# Members 동기화 후 existing_members 갱신
new_member_count = sync_members_to_airtable(api, members_data)
if new_member_count > 0:
    # 새로 추가된 members의 record_id 다시 조회
    existing_members = get_existing_records(members_table, 'Member Code')
```

---

### 6. 코드 중복 (심각도: 낮음)

#### 문제점

**6-1. 페이지네이션 로직 반복**

```python
# syncer.py, airtable_syncer.py에서 동일 패턴 5회 이상 반복
page_size = 1000
offset = 0
while True:
    result = supabase.table(...).select('*').range(offset, offset + page_size - 1).execute()
    if not result.data:
        break
    # 처리...
    offset += page_size
```

**6-2. 필드 매핑 하드코딩**

```python
# airtable_syncer.py:54-65
record = {
    'Member Code': member_code,
    'Username': row.get('Username') or '',
    'E-mail': row.get('E-mail') or '',
    # ... 10개 필드 수동 매핑
}
```

#### 개선안

```python
# utils.py
def paginate_supabase(table, page_size=1000):
    """제너레이터로 페이지네이션 추상화"""
    offset = 0
    while True:
        result = table.select('*').range(offset, offset + page_size - 1).execute()
        if not result.data:
            break
        yield from result.data
        offset += page_size

# config.py에 필드 매핑 정의
FIELD_MAPPINGS = {
    'members': ['Member Code', 'Username', 'E-mail', ...],
    'orders': ['Order Number', 'Product name', ...],
}
```

---

## 종합 평가

### 점수표

| 영역 | 현재 상태 | 점수 |
|------|-----------|------|
| 기능 완성도 | 핵심 기능 동작 | 8/10 |
| 성능 효율성 | 중복 호출, 메모리 이슈 | 5/10 |
| 에러 처리 | 기본적 try-except만 | 4/10 |
| 데이터 정합성 | 일부 엣지 케이스 누락 | 6/10 |
| 코드 품질 | 중복 있으나 가독성 좋음 | 7/10 |
| **종합** | | **6/10** |

### 우선순위별 개선 권장

#### P0 (즉시 수정)
1. **환불 상태 변경 시 is_refunded 업데이트 누락** - 데이터 정합성 버그

#### P1 (단기 개선)
2. 에러 재시도 로직 추가
3. 중복 Supabase 조회 제거

#### P2 (중기 개선)
4. 메모리 효율성 개선 (스트리밍 처리)
5. Airtable Linked Records 타이밍 수정

#### P3 (장기 개선)
6. 코드 중복 제거 (유틸리티 함수화)
7. 필드 매핑 설정 파일화

---

## How (어떻게)

#### 진행 방법

1. 각 파일(main.py, syncer.py, airtable_syncer.py, config.py) 순차 분석
2. 데이터 흐름도 작성 및 병목점 식별
3. 엣지 케이스 시나리오 검토
4. 문제점별 심각도 평가 및 개선안 도출

#### 진행 상태

완료
